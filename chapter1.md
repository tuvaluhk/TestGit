# A Primer on Memory Consistency and Cache Coherence by Daniel J. Sorin, Mark D. Hill, and David A. Wood

## 一、*Consistency*与*coherence*（内存一致性与缓存一致性）

​	把存储正确性分为两个子问题：*consistency*与*coherence*

​	**consistency**: *consistency*的工作是定义共享内存的正确性，它的定义提供了加载、存储的规则（或内存读和写）和在内存上的实现方法。**单线程单处理器核**的正确标准为一个正确行为与很多不正确行为，因为处理器结构执行一个线程是把给定的输入状态转换到一个定义好的输出状态。

​	共享内存一致性模型考虑的是多线程的加载与存储且包含许多**正确**的执行与更多**不正确**的执行，这是由ISA支持多线程同时执行，导致不同线程间有许多**合法交叉的指令集**。这使对正确执行的判断变得复杂。

​	**coherence**: Coherence追求像单核系统一样，使共享内存系统中的cache功能上透明（**对CPU而言**）。好的连贯性确保程序员通过分析加载和存储的结果不能确定系统在哪里安排了cache。

​	在许多系统中，缓存一致性协议在提供内存一致性起重要作用，**第二章**介绍缓存一致性。

### 1.1  一致性（内存一致性、内存一致性模型、内存模型）	

​	一致性模型在不考虑cache或连贯性的前提下，定义**正确（合法）**的**装载、存储（即内存读写）**。现实中直观的例子可以帮助我们理解**为什么需要一致性模型**，比如学校有线上课程表，假设计算机体系结构这门课原本安排在152教室上。上课前一天，教务主任临时决定把教室改为252。教务主任先给网站管理员发e-mail请求更新课程表，几分钟后教务主任给上课的学生发检查更新课程表的信息。不难想象这么一个场景——假如，**网站管理员没有立刻把课表的更新上传**——同时，某个勤奋的学生收到信息后立刻检查网上的课程表，发现教室还是152。这样，即使课室最终改为252且教务主任采取正确的**“修改”**顺序，这个勤奋的学生却以**不同的顺序**留意到这些“修改”最终跑错教室。一致性模型定义**共享内存的某个行为**是**正确**还是**错误**。

​	共享内存硬件实现如果出现故障的处理核、写缓存、多个缓存库，例子中相似的行为就会发生。因此，我们需要定义**共享内存正确性**——共享内存的什么行为是允许的——程序员才知道程序的预期结果。

​	共享内存正确性由内存一致性模型规定的，内存模型规定了在共享内存上所允许的多线程程序行为。对使用指定输入数据的**多线程程序**，内存模型规定了**动态负载可能的返回值**和**内存的可能最终状态**。

​	**第三章**引入了内存一致性模型和**顺序一致性模型（SC）**，SC是最强大和直观的一致性模型。这章从规定共享内存行为的需求开始并准确定义了什么是内存一致性模型。下一步深入研究了直观的SC模型，SC模型规定多线程实现看起来是各个组成线程的顺序执行的交织，好像线程在单核处理器上时分复用一样。

​	**第四章**关注**x86**和**SPARC**系统实现的内存一致性模型，成为**total store order(TSO)总存储顺序**，它使用FIFO写缓存在把结果写入缓存前保存现存储的结果。TSO不符合SC，但是它提供的性能优势足以使我们为TSO设计专门的实现架构。

​	**第五章**介绍了**“relaxed”**和**“weak”**内存一致性模型，这是因为大部分内存呢排序在强模型里是不必要的。如果一个线程是更新10个数据对象后再更新同步标志，但程序员并不关心数据更新的顺序，只关心数据更新与标志更新的顺，Relaxed模型抓住这种排序的灵活性去追求更高的性能或更简的实现。实现了一个relaxed一致性模型的例子，**XC**，在XC里，只在程序员使用**FENCE指令**（FENCE在最后一个数据更新后在标志写前）要求时，才执行排序。

### 1.2一致性（缓存一致性）

​	除非谨慎处理，否则在多个角色（比如：多个核）都可以访问一个**基准数据**（datum）【比如：在多个cache中】且至少一个访问有写的权限时，连贯性问题就来了。举一个直观的例子：一个学生检查教务网站的课表，发现在152教室上课（**读基准数据**），她抄了一份在她的笔记本（**把基准数据放在cache里**）。随后（subsequently），老师打算改到252教室去上课并更新了课表（**写基准数据**）。结果，学生笔记本里的数就过时了，就说有一个**不一致问题**。

​	避免访问过时数据（不连贯）要使用一致性协议，它是由系统内角色的分布集实现的，它由很多变体但遵循着几个主题，在6-9章。

​	**第六章**介绍了缓存一致性协议的概述为后面章节的具体缓存一致性协议作铺垫，主要包含大部分缓存一致性协议存在的问题比如**内存控制器和缓存控制器的分布式操作**与常见的**MOESI缓存状态表**：modified(M),owned(O),exclusive(E),shared(S),invalid(I)。更重要的是，第六章介绍了使用表驱动方法实现的包含稳态和瞬态(transient coherence states)的协议。正式实现包含瞬态的原因是现代系统很少允许从稳态到稳态的原子转换。（例如：Invalid状态中的读miss需要花时间等待数据回应才能进入Shared状态）

​	**第七章**包含监听缓存一致性协议，在hand-wave阶段，监听协议是简单的。当一个缓存未命中发生时，核的缓存控制器控制一个共享总线并广播它的请求。共享总线**确保所有控制器以相同顺序注意到任何请求**，这样所有控制器可以协调它们自身的或分布的动作来确保整体**维持不变的状态**。但是监听协议很复杂，因为系统可能使用多条总线且现代的总线不会原子性（atomically）地处理请求。现代总线存在各自的控制队列而且可以发送单播、被流水线延迟、故障的回应，这些属性导致了更多的瞬态。

​	**第八章**深入研究了索引缓存一致性协议，它比依赖广播的监听协议可以扩展到更多的核数或其它参与者。索引协议间接解决缓存的一致性问题，它维持一个跟踪哪个缓存存着主存那个位置数据的目录。根据所请求的**内存地址的目录条目**，控制器把回应发给请求者或把请求消息发给一个或更多存有该地址数据的参与者。每条消息通常有一个目的地（意思是不存在多播或广播），但缓存一致性的状态的瞬态会大量增长，因为从一个稳定的一致性状态转换到另一个会根据系统中的参与者数对应地产生许多消息。

​	**第九章**关注部分缓存一致性的高级主题，为了便于解释基本问题，之前的章节都使用最简单的系统模型。第九章深入研究复杂系统模型和优化，关注的是监听与索引邪恶一共有的问题。基本的主题有处理指令缓存、多级缓存、直写缓存、旁路转换缓存。



